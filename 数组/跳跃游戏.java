// (JAVA)

// 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的
// 最后一个位置。

// 示例:
// 输入: [2,3,1,1,4]
// 输出: 2 （解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。)

// 说明:
// 假设你总是可以到达数组的最后一个位置。

// *-------------------------------------------------------------------------------------------------------------------------------*
// 解题思路：（[2,3,1,1,4]）
// 从数组的第 0 个位置开始跳，跳的距离小于等于数组上对应的数。求出跳到最后个位置需要的最短步数。比如第 0 个位置是 2，那么可以跳 1 个
// 距离，或者 2 个距离，我们选择跳 1 个距离，就跳到了第 1 个位置，也就是 3 上。然后我们可以跳 1，2，3 个距离，我们选择跳 3 个距离，就直接到
// 最后了。所以总共需要 2 步。

// 解法一 ：顺藤摸瓜
// LeetCode 讨论里，大部分都是这个思路，贪婪算法，我们每次在可跳范围内选择可以使得跳的更远的位置。
//  -开始的位置是 2，可跳的范围是[3,1]。然后因为 3 可以跳的更远，所以跳到 3 的位置。
//  -然后现在的位置就是 3 了，能跳的范围是[1,1,4]，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。

// 写代码的话，我们用 end 表示当前能跳的边界，遍历数组的时候，到了边界，我们就重新更新新的边界。

// *-------------------------------------------------------------*
public int jump(int[] nums) {
    int end = 0;
    int maxPosition = 0; 
    int steps = 0;
    for(int i = 0; i < nums.length - 1; i++){
        // 下一次找能跳的最远的
        maxPosition = Math.max(maxPosition, nums[i] + i); 
        //遇到边界，就更新边界，并且步数加一
        if(i == end){ 
            // 下一次的边界
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}

// *-------------------------------------------------------------*
// -时间复杂度：O(n)。
// -空间复杂度：O(1)。

// 这里要注意一个细节，就是 for 循环中，i < nums.length - 1，少了末尾。因为开始的时候边界是第 0 个位置，steps 已经加 1 了。如果最后
// 一步刚好跳到了末尾，此时 steps 其实不用加 1 了。如果是 i < nums.length，i 遍历到最后的时候，会进入 if 语句中，steps 会多加 1。

// *-------------------------------------------------------------------------------------------------------------------------------*
// 解法二：顺瓜摸藤
// 我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后
// 到了第 0 个位置就结束了。至于离它最远的位置，其实我们从左到右遍历数组，第一个满足的位置就是我们要找的。

// *-------------------------------------------------------------*
public int jump(int[] nums) {
    int position = nums.length - 1; //要找的位置
    int steps = 0;
    while (position != 0) { //是否到了第 0 个位置
        for (int i = 0; i < position; i++) {
            if (nums[i] >= position - i) {
                position = i; //更新要找的位置
                steps++;
                break;
            }
        }
    }
    return steps;
}

// *-------------------------------------------------------------*
// -时间复杂度：O(n²)，因为最坏的情况比如 1111111，position 会从 5 更新到 0，并且每次更新都会经历一个 for 循环。
// -空间复杂度：O(1)。
