// (JAVA)

// 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

// 示例 1:
// 输入: "(()"
// 输出: 2 (解释: 最长有效括号子串为 "()")

// 示例 2:
// 输入: ")()())"
// 输出: 4 (解释: 最长有效括号子串为 "()()")

// *-----------------------------------------------------------------------------------------------------------------------------*
// 方法 1：暴力
// 算法:
// 在这种方法中，我们考虑给定字符串中每种可能的非空偶数长度子字符串，检查它是否是一个有效括号字符串序列。为了检查有效性，我们使用栈的方法。
// 每当我们遇到一个 ‘(’ ，我们把它放在栈顶。对于遇到的每个 ‘)’ ，我们从栈中弹出一个 ‘(’ ，如果栈顶没有 ‘(’，或者遍历完整个子字符串后栈中
// 仍然有元素，那么该子字符串是无效的。这种方法中，我们对每个偶数长度的子字符串都进行判断，并保存目前为止找到的最长的有效子字符串的长度。

// 例子:
    // "((())"

    // (( --> 无效
    // (( --> 无效
    // () --> 有效，长度为 2
    // )) --> 无效
    // ((()--> 无效
    // (())--> 有效，长度为 4
    // 最长长度为 4

// *---------------------------------------------------------------------*
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<Character>();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stack.push('(');
        } else if (!stack.empty() && stack.peek() == '(') {
            stack.pop();
        } else {
            return false;
        }
    }
    return stack.empty();
}
public int longestValidParentheses(String s) {
    int maxlen = 0;
    for (int i = 0; i < s.length(); i++) {
        for (int j = i + 2; j <= s.length(); j+=2) {
            if (isValid(s.substring(i, j))) {
                maxlen = Math.max(maxlen, j - i);
            }
        }
    }
    return maxlen;
}

// *---------------------------------------------------------------------*
// 复杂度分析:
// -时间复杂度： O(n^2)。从长度为 n 的字符串产生所有可能的子字符串需要的时间复杂度为 O(n^2)。验证一个长度为 nn 的子字符串需要的时间为 O(n)。
// -空间复杂度： O(n)。子字符串的长度最多会需要一个深度为 n 的栈。

// *-----------------------------------------------------------------------------------------------------------------------------*
// 方法 2：动态规划
// 算法:
// 这个问题可以通过动态规划解决。我们定义一个 dp 数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。我们将 dp 数组全部
// 初始化为 0 。现在，很明显有效的子字符串一定以 ‘)’ 结尾。这进一步可以得出结论：以 ‘(’ 结尾的子字符串对应的 dp 数组位置上的值必定为 0 。所
// 以说我们只需要更新 ‘)’ 在 dp 数组中对应位置的值。为了求出 dp 数组，我们每两个字符检查一次，如果满足如下条件:
// -s[i]=‘)’ 且 s[i−1]=‘(’ ，也就是字符串形如"……()"，我们可以推出：
//     dp[i]=dp[i−2]+2
//     我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。
// -s[i]=‘)’ 且 s[i−1]=‘)’，也就是字符串形如 "……))" ，我们可以推出：
//     如果 s[i−dp[i−1]−1]=‘(’ ，那么 dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2
//     这背后的原因是如果倒数第二个 ‘)’ 是一个有效子字符串的一部分（记为 sub_s），对于最后一个 ‘)’ ，如果它是一个更长子字符串的一部分，那么
//     它一定有一个对应的 ‘(’ ，它的位置在倒数第二个 ‘)’ 所在的有效子字符串的前面（也就是 sub_s 的前面）。因此，如果子字符串 sub_s 的前面恰
//     好是 ‘(’ ，那么我们就用 2 加上 sub_s 的长度（dp[i−1]）去更新 dp[i]。除此以外，我们也会把有效子字符串 "(,sub_s,)" 之前的有效子字符串
//     的长度也加上，也就是加上 dp[i−dp[i−1]−2]。

// *---------------------------------------------------------------------------------------------------*
public int longestValidParentheses(String s) {
    int maxans = 0;
//     dp[i]: 直至dp[i]的有效长度（初始化为0）
    int dp[] = new int[s.length()];
    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == ')') {
//             此时为‘()’，所以为 i-2
            if (s.charAt(i - 1) == '(') {
                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
            } 
//             i - dp[i - 1] > 0: 保证s[i]还有‘(’可以匹配 （不符合情况时：s[0]~s[i]已经有效）
            else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
            }
            maxans = Math.max(maxans, dp[i]);
        }
    }
    return maxans;
}

// *---------------------------------------------------------------------------------------------------*
// 复杂度分析:
// -时间复杂度：O(n)。遍历整个字符串一次，就可以将 dp 数组求出来。
// -空间复杂度：O(n)。需要一个大小为 n 的 dp 数组。

// *-----------------------------------------------------------------------------------------------------------------------------*
// 方法 3：栈
// 算法:
// 与找到每个可能的子字符串后再判断它的有效性不同，我们可以用栈在遍历给定字符串的过程中去判断到目前为止扫描的子字符串的有效性，同时能的都最
// 长有效字符串的长度。我们首先将 -1 放入栈顶。
// -对于遇到的每个 ‘(’ ，我们将它的下标放入栈中。
// -对于遇到的每个 ‘)’ ，我们弹出栈顶的元素并将当前元素的下标与弹出元素下标作差，得出当前有效括号字符串的长度。通过这种方法，我们继续计算有效
//  子字符串的长度，并最终返回最长有效子字符串的长度。

// *--------------------------------------------------------------------------*
public int longestValidParentheses(String s) {
    int maxans = 0;
    Stack<Integer> stack = new Stack<>();
    stack.push(-1);
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.empty()) {
                stack.push(i);
            } else {
//                 peek()：查看堆栈顶部的对象，但不从堆栈中移除它。
                maxans = Math.max(maxans, i - stack.peek());
            }
        }
    }
    return maxans;
}


// *--------------------------------------------------------------------------*
// 复杂度分析:
// -时间复杂度：O(n)。n 是给定字符串的长度。
// -空间复杂度：O(n)。栈的大小最大达到 n。

// *-----------------------------------------------------------------------------------------------------------------------------*
// 方法 4：不需要额外的空间
// 算法:
// 在这种方法中，我们利用两个计数器 left 和 right。
// 首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加 left 计算器，对于遇到的每个 ‘)’ ，我们增加 right 计数器。每当 left 计数器与 
//      right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。如果 right 计数器比 left 计数器大时，我们将 
//      left 和 right 计数器同时变回 0 。
// 接下来，我们从右到左做一遍类似的工作。

// *-------------------------------------------------------------*
public int longestValidParentheses(String s) {
    int left = 0, right = 0, maxlength = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) {
            maxlength = Math.max(maxlength, 2 * right);
        } else if (right >= left) {
            left = right = 0;
        }
    }
    left = right = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) {
            maxlength = Math.max(maxlength, 2 * left);
        } else if (left >= right) {
            left = right = 0;
        }
    }
    return maxlength;
}

// *-------------------------------------------------------------*
// 复杂度分析:
// -时间复杂度： O(n)。遍历两遍字符串。
// -空间复杂度： O(1)。仅有两个额外的变量 left 和 right。
