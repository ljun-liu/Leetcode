(JAVA)

// 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
// 可以假设数组中无重复元素。

// 示例 1:
// 输入: [1,3,5,6], 5
// 输出: 2

// 示例 2:
// 输入: [1,3,5,6], 2
// 输出: 1

// 示例 3:
// 输入: [1,3,5,6], 7
// 输出: 4

// 示例 4:
// 输入: [1,3,5,6], 0
// 输出: 0

// 二分查找（详解-见leetcode35）

// *---------------------------------------------------------------------------------------------------------------------------*
// **根据 mid 被分到左边区间还是右边区间，代码写出来只有以下 2 种（重难点）：**
// ◾边界收缩行为 1： mid 被分到左边。即区间被分成 [left, mid] 与 [mid + 1, right]，这里用“闭区间”表示区间端点可以取到，下同；

// *---------------------------------------------------------------------------------*
if (check(mid)) {
    // 下一轮搜索区间是 [left, mid]，因此把右边界设置到 mid 位置
    right = mid;
} else {
    // 上面对了以后，剩下的区间一定是 [mid + 1, right]，因此左边界向右收缩到 mid + 1
    left = mid + 1;
}

// *---------------------------------------------------------------------------------*
// 说明：这里的 check(mid) 函数通常是一个表达式，在一些情况下有可能逻辑比较复杂，建议专门抽取成一个私有方法，以突显主干逻辑。

// ◾边界收缩行为 2： mid 被分到右边。即区间被分成 [left, mid - 1] 与 [mid, right]；

// *---------------------------*
if (check(mid)) {
    right = mid - 1;
} else {
    left = mid;
}

// *---------------------------------------------------------------------------------------------------------------------------*
// **根据“边界收缩行为”修改取中间数的行为（重难点）。**
// 先说一下中间数的取法。一般是这样的：

// *--------------------------------*
int mid = (left + right) / 2;

// *--------------------------------*
// 这种写法在绝大多数情况下没问题，但是在 left 和 right 特别大的场景中，left + right 会发生整形溢出，得到一个负数，mid 的值随之也是
// 负数。改进的写法是：

// *--------------------------------------*
int mid = left + (right - left) / 2;

// *--------------------------------------*
// 这两种写法事实上没有本质的区别，在 left 和 right 都表示数组索引的时候，几乎不会越界，因为绝大多数情况下不会开那么长的数组。
// 这里有一个细节，/ 是整除，它的行为是“向下取整”，造成了 int mid = (left + right) / 2 这种写法 mid 永远取不到带搜索区间里最右边的位置。
// 面对上面的“边界收缩行为 2”（mid 被分到右边），在待搜索区间收缩到只剩下 2 个元素的时候，就有可能造成死循环。
