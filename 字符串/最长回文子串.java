// (JAVA)

// 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

// 示例 1：
// 输入: "babad"
// 输出: "bab" （注意: "aba" 也是一个有效答案。）

// 示例 2：
// 输入: "cbbd"
// 输出: "bb"
  
// *----------------------------------------------------------------------------------------------------------------------------------*
// 方法一：最长公共子串
// 常见错误：反转 S，使之变成 S' 。找到 S 和 S' 之间最长的公共子串，这也必然是最长的回文子串。
//          失败例子：S=“abacdfgdcaba”, S'=“abacdgfdcaba”：S 以及 S' 之间的最长公共子串为 “abacd”。显然，这不是回文。

// 算法:
// 为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到
// 的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。

// 这给我们提供了一个复杂度为 O(n^2) 动态规划解法，它将占用 O(n^2) 的空间（可以改进为使用 O(n) 的空间）。

// *----------------------------------------------------------------------------------------------------------------------------------*
// 方法二：暴力法
// 很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。

// 复杂度分析：
// -时间复杂度:O(n^3)，假设 n 是输入字符串的长度，则 \binom{n}{2} = n(n-1)/2 为此类子字符串(不包括字符本身是回文的一般解法)的总数。因为验证每个
//           子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n^3)。
// -空间复杂度：O(1)。

// *----------------------------------------------------------------------------------------------------------------------------------*
// 方法三：动态规划
// 为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 
// 一定是回文，因为它的左首字母和右尾字母是相同的。

// P(i,j): P(i,j)=(P(i+1,j−1) and S(i) == S(j))
// 基本示例如下：
// -P(i, i) = true
// -P(i, i+1) = ( S_i == S_{i+1} )
// 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…

// 复杂度分析:
// -时间复杂度：O(n^2)，这里给出我们的运行时间复杂度为 O(n^2)。
// -空间复杂度：O(n^2)，该方法使用 O(n^2) 的空间来存储表。

// *----------------------------------------------------------------------------------------------------------------------------------*
// 方法四：中心扩展算法
// 事实上，只需使用恒定的空间，我们就可以在 O(n^2) 的时间内解决这个问题。
// 我们观察到回文中心的两侧互为镜像。因此，*回文可以从它的中心展开，并且只有 2n - 1 个这样的中心*。
// 你可能会问，为什么会是 2n - 1，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。

// *--------------------------------------------------------*
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    int start = 0, end = 0;
    // i为中心点索引
    for (int i = 0; i < s.length(); i++) {
        // 查找以"S(i)"为中心
        int len1 = expandAroundCenter(s, i, i);
        // 查找以"S(i)S(i+1)"为中心
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            // len-1: 除去中心点（"S(i)"或"S(i)S(i+1)"）的数量 （中心点为2时会多加1 <- 2/2=1）
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}

// *--------------------------------------------------------*
// 复杂度分析:
// -时间复杂度：O(n^2)，由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n^2)。
// -空间复杂度：O(1)。

// *----------------------------------------------------------------------------------------------------------------------------------*
// 方法五：Manacher 算法

// (Python)
def manacher(s):
    #预处理
    s = '#' + '#'.join(s) + '#'
    
    # RL: 以字符为中心的半径
    RL = [0] * len(s)
    MaxRight=0
    pos=0
    MaxLen=0
    for i in range(len(s)):
        if i < MaxRight:
            RL[i] = min(RL[2 * pos - i], MaxRight - i)
        else:
            RL[i] = 1
        # 尝试扩展，注意处理边界
        while (i - RL[i]) >= 0 and (i + RL[i]) < len(s) and s[i - RL[i]] == s[i + RL[i]]:
            RL[i] += 1
        # 更新MaxRight,pos
        if RL[i] + i - 1 > MaxRight:
            MaxRight = RL[i] + i - 1
            pos = i
        # 更新最长回文串的长度
        MaxLen = max(MaxLen, RL[i])
    return MaxLen - 1
              
// (JAVA)
public int longestPalindrome(String s) {
    int n=s.length();
    boolean[][] pal=new boolean[n][n];
    // pal[i][j] 表示s[i...j]是否是回文串
    int maxLen=0;
    // i作为终点
    for (int i=0;i<n;i++){  
        // j作为起点
        int j=i;    
        while (j>=0){
            if (s.charAt(j)==s.charAt(i)&&(i-j<2||pal[j+1][i-1])){
                pal[j][i]=true;
                maxLen=Math.max(maxLen, i-j+1);
            }
            j--;
        }
    }
    return maxLen;
}  
