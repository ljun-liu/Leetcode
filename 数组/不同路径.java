// (JAVA; python 3)

// 一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？
// 说明：m 和 n 的值均不超过 100。

// 示例 1:
// 输入: m = 3, n = 2
// 输出: 3 （解释: 从左上角开始，总共有 3 条路径可以到达右下角。
//               1. 向右 -> 向右 -> 向下
//               2. 向右 -> 向下 -> 向右
//               3. 向下 -> 向右 -> 向右）
              
// 示例 2:
// 输入: m = 7, n = 3
// 输出: 28

// *-----------------------------------------------------------------------------------------------------------------------------*
// 思路一：排列组合
// 因为机器到底右下角，向下几步，向右几步都是固定的，比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。所以有 C_{m+n-2}^{m-1}
// （一共走m+n-2步，其中选定m-1步以后，剩下的n-1步也定下了，即从m+n-2中选择m-1）
// [0][1][2]...[m+n-3]里选择m-1个为向右走
 
// *--------------------------------------------------------------------------------------*
// (python 3)
def uniquePaths(self, m: int, n: int) -> int:
//         math.factorial: 乘阶
        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))
          
// *-----------------------------------------------------------------------------------------------------------------------------*
// 思路二：动态规划
// 我们令 dp[i][j] 是到达 i, j 最多路径，动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]
// 注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1

// 时间复杂度：O(m∗n)
// 空间复杂度：O(m∗n)

// 优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]，所以我们只要记录这两个数

// *-------------------------------------------------------*
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < n; i++) dp[0][i] = 1;
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];  
}

// *-------------------------------------------------------*
// 优化1：空间复杂度 O(2n)

// *-------------------------------------------------------*
public int uniquePaths(int m, int n) {
    int[] pre = new int[n];
    int[] cur = new int[n];
    Arrays.fill(pre, 1);
    Arrays.fill(cur,1);
    for (int i = 1; i < m;i++){
        for (int j = 1; j < n; j++){
            cur[j] = cur[j-1] + pre[j];
        }
//         深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。
//         ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。
        pre = cur.clone();
    }
    return pre[n-1]; 
}

// *-------------------------------------------------------*
// 优化2：空间复杂度 O(n)

// *-------------------------------------------*
public int uniquePaths(int m, int n) {
    int[] cur = new int[n];
    Arrays.fill(cur,1);
    for (int i = 1; i < m;i++){
        for (int j = 1; j < n; j++){
//             cur[0]永远为1
            cur[j] += cur[j-1] ;
        }
    }
    return cur[n-1];
}

// *-------------------------------------------*
