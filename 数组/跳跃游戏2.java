// (JAVA)

// 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

// 示例 1:
// 输入: [2,3,1,1,4]
// 输出: true (解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。)

// 示例 2:
// 输入: [3,2,1,0,4]
// 输出: false (解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。)

// *--------------------------------------------------------------------------------------------------------------------------*
// 回溯；自顶向下；自底向上 - 见leetcode 55

// *--------------------------------------------------------------------------------------------------------------------------*
// 方法 4：贪心算法

// *--------------------------------------------------------*
public boolean canJump(int[] nums) {
    int lastPos = nums.length - 1;
    for (int i = nums.length - 1; i >= 0; i--) {
//        lastPos: 终点或等价于（即可以到达终点）的位置
//        i + nums[i]: 能跳转至目的位置且距离目的位置最近的点
        if (i + nums[i] >= lastPos) {
            lastPos = i;
        }
    }
//   等于0说明目的位置，即可跳转值终点的点最终为起点
    return lastPos == 0;
}

// *--------------------------------------------------------*
// 复杂度分析:
// -时间复杂度：O(n，只需要访问 nums 数组一遍，共 n 个位置，n 是 nums 数组的长度。
// -空间复杂度：O(1)，不需要额外的空间开销。

// 总结:
// -最后一个问题是，如何在面试场景中想到这个做法。我的建议是“酌情考虑”。最好的解法当然和别的解法相比更简单也更短，但是不那么容易直接想到。
// -递归回溯的版本最容易想到，所以在思考更复杂解法的时候可以顺带提及一下这个解法，你的面试官实际上可能会想要看到这个解法。但如果没有，请提及可以
//    使用动态规划的解法，并试想一下如何用记忆表来实现。如果你发现面试官希望你回答自顶向下的方法，那么就不太需要思考自底向上的版本，但我推荐在面试
//    中提及一下自底向下的优点。
// -很多人会在将自顶向下的动态规划转成自底向上版本时出现困难，多做一些相关的练习可以对你有所帮助。

// *--------------------------------------------------------------------------------------------------------------------------*
// (C++)
bool canJump(vector<int>& nums) 
{
	int k = 0;
	for (int i = 0; i < nums.size(); i++)
	{
//     k: 从0开始所能到达的最远的位置
//     i<=k时，说明从k无法到达i，即k无法到达终点
		if (i > k) return false;
		k = max(k, i + nums[i]);
	}
	return true;
}
